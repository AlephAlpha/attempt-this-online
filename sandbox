#!/usr/bin/zsh
# Note that this script is written in zsh, so we can use all of its -isms, such as unquoted variable expansions.

# We *should* be able to trust that this script is only run from by the trusted API process, but if an attacker somehow
# got RCE as the API user, they might be able to LPE using this + bwrap, so make sure everything is written securely!

setopt errexit

invocation_id=$1
language=$2
timeout=$3
image=$(printf %s $4 | tr / +)

# check that the runner exists (also prevents directory traversal)
ls /usr/local/share/ATO/runners | grep -Fqx $language

# check that the image exists
ls /usr/local/lib/ATO/rootfs | grep -Fqx $image

# ensure minimum lengths
[[ $#invocation_id -gt 16 ]]
[[ $timeout -gt 1 ]] && [[ $timeout -le 60 ]]

# make sure ID is path-safe by getting a hashed version in hex
echo -n $invocation_id | sha256sum | read invocation_id _

# Open a file descriptor where we will write all the status information. See zshmisc(1) ยง Opening File Descriptors
# Using Parameters for more details.
exec {status_fd}>/run/ATO/$invocation_id/status
# Open file descriptor for sandbox details, which will be written by bwrap immediately, to allow the process to be
# killed manually
exec {info_fd}>/run/ATO/$invocation_id/info

# Define resource limits (see zshbuiltins(1) ยง ulimit and setrlimit(2))
# -S means soft limit - the process will get a signal when it reaches this limit
# -H means hard limit - processes absolutely cannot go past this
# the soft limits are slightly less than the hard limits so that processes have a chance to recover

# use a cgroup to manage memory limits
# TODO: dynamically work out $cg path, rather than relying on hard-coded cgroup fs mount point and systemd cgroup layout
cg=/sys/fs/cgroup/system.slice/ATO.service/$invocation_id
# ensure cgroup is cleaned up
trap "rmdir $cg" EXIT
# create the cgroup
mkdir -p $cg

(  # enter a subshell; the limits don't apply outside it
read subshell_pid _ </proc/self/stat

# core file size
ulimit -H -c 0 # i.e., disallow core files

for code value (
    f 1048576 # file size (in 512B blocks, so 512MiB)
    u 100     # processes (actually threads)
    i 100     # pending signals
    x 100     # file locks
    q 65536   # bytes in POSIX message queues
) {
    ulimit -S -$code $[value - 2]
    ulimit -H -$code $value
}

echo 209715200 >$cg/memory.high # create memory pressure if 200MiB used
echo 268435456 >$cg/memory.max  # absolute maximum memory 256MiB
echo 0 >$cg/memory.swap.max     # disallow swap
# join cgroup in this subshell
echo $subshell_pid >$cg/cgroup.procs

# (I wish it was possible to add comments between line continuations)
# - env -i: start with a clean/empty environment
# - yargs: pass the arguments from `/usr/local/lib/ATO/env/$image` to bwrap (they are in the form `--setenv var name`,
#   and generated by `setup/parse_env`)
#   bwrap: run inside a container
env -i \
/usr/local/bin/ATO_yargs % /usr/local/lib/ATO/env/$image \
bwrap % \
    --ro-bind /usr/local/lib/ATO/rootfs/$image / \
    --proc /proc \
    --dev /dev \
    --tmpfs /ATO \
    --ro-bind /usr/local/bin/ATO_bash /ATO/bash \
    --ro-bind /usr/local/bin/ATO_yargs /ATO/yargs \
    --ro-bind /usr/local/bin/ATO_wrapper /ATO/wrapper \
    --ro-bind /usr/local/share/ATO/runners/$language /ATO/runner \
    --dir /ATO/context \
    --chdir /ATO \
    --unshare-all \
    --die-with-parent \
    --hostname ATO_sandbox \
    --info-fd $info_fd \
    --ro-bind /run/ATO/$invocation_id/input /ATO/input \
    --ro-bind /run/ATO/$invocation_id/code /ATO/code \
    --ro-bind /run/ATO/$invocation_id/arguments /ATO/arguments \
    --ro-bind /run/ATO/$invocation_id/options /ATO/options \
    /ATO/wrapper $status_fd $timeout
)

# close status FDs
exec {status_fd}>&-
exec {info_fd}>&-
