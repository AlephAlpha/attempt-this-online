#!/usr/bin/zsh
# Note that this script is written in zsh, so we can use all of its -isms, such as unquoted variable expansions.

# We *should* be able to trust that this script is only run from by the trusted API process, but if an attacker somehow
# got RCE as the API user, they might be able to LPE using this + bwrap, so make sure everything is written securely!

setopt errexit

client_id=$1
invocation_id=$2
language=$3
timeout=$4
image=$(printf %s $5 | tr / +)

# check that the runner exists (also prevents directory traversal)
ls /usr/local/share/ATO/runners | grep -Fqx $language

# check that the image exists
ls /usr/local/lib/ATO/rootfs | grep -Fqx $image

# ensure minimum lengths
[[ $#client_id -gt 16 ]]
[[ $#invocation_id -gt 16 ]]
[[ $timeout -gt 1 ]] && [[ $timeout -le 60 ]]

# make sure IDs are path-safe by getting a hashed version in hex
echo -n $client_id | sha256sum | read client_id _
echo -n $invocation_id | sha256sum | read invocation_id _

# Create a control group for this client and this invocation to manage resource usage. I'm not sure why this needs a
# lock, but TIO uses one :shrug: (https://github.com/TryItOnline/tryitonline/blob/898a41f69eeeff915b579bf4602b3ed9aea07910/bin/run#L19)
flock -s /run/lock/ATO/$client_id \
    cgcreate -g memory,cpu,pids:ATO/$client_id/$invocation_id

# Limit the available resources to the process
#
# - Memory "soft" limit: allow the process to use as much memory as it likes, as long as there is plenty available. If
#   the system begins to get low on memory, it will be limited to 256M per client (connecting IP address), and 128M per
#   individual invocation by that user.
#
# - CPU shares: similarly, allow the process as much CPU usage as it wants, unless the system starts to get overloaded.
#   In these cases, each client will be limited to 128 "shares" and each process to 64 "shares". "Shares" are a
#   proportional but arbitrary sized chunk of CPU resources which is used to determine the priority assigned to a given
#   process. Typically, systemd assigns 1024 shares to each process "slice".
#
# - PIDs: pretty simple - prevent the process from hoovering up all kernel resources with fork bombs and the like by
#   limiting to 64 processes per invocation and 256 per client.
#
# Further reading:
#
# - man cgroups(7)
# - https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/memory.html
# - https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html
# - https://engineering.squarespace.com/blog/2017/understanding-linux-container-scheduling
cgset -r memory.soft_limit_in_bytes=256M ATO/$client_id
cgset -r memory.soft_limit_in_bytes=128M ATO/$client_id
cgset -r cpu.shares=64 ATO/$client_id
cgset -r cpu.shares=16 ATO/$client_id/$invocation_id
cgset -r pids.max=256 ATO/$client_id
cgset -r pids.max=64 ATO/$client_id/$invocation_id

# Open a file descriptor where we will write all the status information. See zshmisc(1) ยง Opening File Descriptors
# Using Parameters for more details.
exec {status_fd}>/run/ATO/$invocation_id/status
# Open file descriptor for sandbox details, which will be written by bwrap immediately, to allow the process to be
# killed manually
exec {info_fd}>/run/ATO/$invocation_id/info

# (I wish it was possible to add comments between line continuations)
# - env -i: start with a clean/empty environment
# - yargs: pass the arguments from `/usr/local/lib/ATO/env/$image` to bwrap (they are in the form `--setenv var name`,
#   and generated by `setup/parse_env`)
# - cgexec: run inside the cgroup defined above
env -i \
/usr/local/bin/ATO_yargs % /usr/local/lib/ATO/env/$image \
cgexec -g memory,cpu,pids:ATO/$client_id/$invocation_id \
bwrap % \
    --ro-bind /usr/local/lib/ATO/rootfs/$image / \
    --proc /proc \
    --dev /dev \
    --tmpfs /ATO \
    --ro-bind /usr/local/bin/ATO_bash /ATO/bash \
    --ro-bind /usr/local/bin/ATO_yargs /ATO/yargs \
    --ro-bind /usr/local/bin/ATO_wrapper /ATO/wrapper \
    --ro-bind /usr/local/share/ATO/runners/$language /ATO/runner \
    --dir /ATO/context \
    --chdir /ATO \
    --unshare-all \
    --die-with-parent \
    --hostname ATO_sandbox \
    --info-fd $info_fd \
    --ro-bind /run/ATO/$invocation_id/input /ATO/input \
    --ro-bind /run/ATO/$invocation_id/code /ATO/code \
    --ro-bind /run/ATO/$invocation_id/arguments /ATO/arguments \
    --ro-bind /run/ATO/$invocation_id/options /ATO/options \
    /ATO/wrapper $status_fd $timeout

# close status FDs
exec {status_fd}>&-
exec {info_fd}>&-

# clean up cgroups
flock -w 0 /run/lock/ATO/$client_id \
    cgdelete -rg memory,cpu,pids:ATO/$client_id/$invocation_id || true
